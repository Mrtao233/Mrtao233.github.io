<!DOCTYPE html>
<html lang="zh-CN">
<head>
  <meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=2">
<meta name="theme-color" content="#222">
<meta name="generator" content="Hexo 6.3.0">
  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png">
  <link rel="mask-icon" href="/images/logo.svg" color="#222">

<link rel="stylesheet" href="/css/main.css">


<link rel="stylesheet" href="/lib/font-awesome/css/all.min.css">

<script id="hexo-configurations">
    var NexT = window.NexT || {};
    var CONFIG = {"hostname":"mrtao233.github.io","root":"/","scheme":"Mist","version":"7.8.0","exturl":false,"sidebar":{"position":"left","display":"post","padding":18,"offset":12,"onmobile":false},"copycode":{"enable":false,"show_result":false,"style":null},"back2top":{"enable":true,"sidebar":false,"scrollpercent":false},"bookmark":{"enable":false,"color":"#222","save":"auto"},"fancybox":false,"mediumzoom":false,"lazyload":false,"pangu":false,"comments":{"style":"tabs","active":null,"storage":true,"lazyload":false,"nav":null},"algolia":{"hits":{"per_page":10},"labels":{"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}},"localsearch":{"enable":false,"trigger":"auto","top_n_per_article":1,"unescape":false,"preload":false},"motion":{"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},"path":"search.xml"};
  </script>

  <meta name="description" content="输入和输出 12345678910int i;float f;cin &gt;&gt; i;cout &lt;&lt; f;------------scanf(&quot;%d&quot;, &amp;i);printf(&quot;%f&quot;, f);----------------连续读入cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cin 1.在默认">
<meta property="og:type" content="article">
<meta property="og:title" content="学习c++前10天">
<meta property="og:url" content="https://mrtao233.github.io/2023/02/11/c00/index.html">
<meta property="og:site_name" content="Mrtao&#39;s blog">
<meta property="og:description" content="输入和输出 12345678910int i;float f;cin &gt;&gt; i;cout &lt;&lt; f;------------scanf(&quot;%d&quot;, &amp;i);printf(&quot;%f&quot;, f);----------------连续读入cin &gt;&gt; a &gt;&gt; b &gt;&gt; c; cin 1.在默认">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2023-02-11T14:13:00.000Z">
<meta property="article:modified_time" content="2023-09-05T15:54:43.804Z">
<meta property="article:author" content="Mrtao">
<meta property="article:tag" content="基础">
<meta name="twitter:card" content="summary">

<link rel="canonical" href="https://mrtao233.github.io/2023/02/11/c00/">


<script id="page-configurations">
  // https://hexo.io/docs/variables.html
  CONFIG.page = {
    sidebar: "",
    isHome : false,
    isPost : true,
    lang   : 'zh-CN'
  };
</script>

  <title>学习c++前10天 | Mrtao's blog</title>
  






  <noscript>
  <style>
  .use-motion .brand,
  .use-motion .menu-item,
  .sidebar-inner,
  .use-motion .post-block,
  .use-motion .pagination,
  .use-motion .comments,
  .use-motion .post-header,
  .use-motion .post-body,
  .use-motion .collection-header { opacity: initial; }

  .use-motion .site-title,
  .use-motion .site-subtitle {
    opacity: initial;
    top: initial;
  }

  .use-motion .logo-line-before i { left: initial; }
  .use-motion .logo-line-after i { right: initial; }
  </style>
</noscript>

</head>

<body itemscope itemtype="http://schema.org/WebPage">
  <div class="container use-motion">
    <div class="headband"></div>

    <header class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-container">
  <div class="site-nav-toggle">
    <div class="toggle" aria-label="切换导航栏">
      <span class="toggle-line toggle-line-first"></span>
      <span class="toggle-line toggle-line-middle"></span>
      <span class="toggle-line toggle-line-last"></span>
    </div>
  </div>

  <div class="site-meta">

    <a href="/" class="brand" rel="start">
      <span class="logo-line-before"><i></i></span>
      <h1 class="site-title">Mrtao's blog</h1>
      <span class="logo-line-after"><i></i></span>
    </a>
  </div>

  <div class="site-nav-right">
    <div class="toggle popup-trigger">
    </div>
  </div>
</div>




<nav class="site-nav">
  <ul id="menu" class="main-menu menu">
        <li class="menu-item menu-item-home">

    <a href="/" rel="section"><i class="fa fa-home fa-fw"></i>首页</a>

  </li>
        <li class="menu-item menu-item-tags">

    <a href="/tags/" rel="section"><i class="fa fa-tags fa-fw"></i>标签</a>

  </li>
        <li class="menu-item menu-item-categories">

    <a href="/categories/" rel="section"><i class="fa fa-th fa-fw"></i>分类</a>

  </li>
        <li class="menu-item menu-item-archives">

    <a href="/archives/" rel="section"><i class="fa fa-archive fa-fw"></i>归档</a>

  </li>
  </ul>
</nav>




</div>
    </header>

    
  <div class="back-to-top">
    <i class="fa fa-arrow-up"></i>
    <span>0%</span>
  </div>


    <main class="main">
      <div class="main-inner">
        <div class="content-wrap">
          

          <div class="content post posts-expand">
            

    
  
  
  <article itemscope itemtype="http://schema.org/Article" class="post-block" lang="zh-CN">
    <link itemprop="mainEntityOfPage" href="https://mrtao233.github.io/2023/02/11/c00/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="image" content="/images/avatar.gif">
      <meta itemprop="name" content="Mrtao">
      <meta itemprop="description" content="第一个博客网站">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Mrtao's blog">
    </span>
      <header class="post-header">
        <h1 class="post-title" itemprop="name headline">
          学习c++前10天
        </h1>

        <div class="post-meta">
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-calendar"></i>
              </span>
              <span class="post-meta-item-text">发表于</span>

              <time title="创建时间：2023-02-11 22:13:00" itemprop="dateCreated datePublished" datetime="2023-02-11T22:13:00+08:00">2023-02-11</time>
            </span>
              <span class="post-meta-item">
                <span class="post-meta-item-icon">
                  <i class="far fa-calendar-check"></i>
                </span>
                <span class="post-meta-item-text">更新于</span>
                <time title="修改时间：2023-09-05 23:54:43" itemprop="dateModified" datetime="2023-09-05T23:54:43+08:00">2023-09-05</time>
              </span>
            <span class="post-meta-item">
              <span class="post-meta-item-icon">
                <i class="far fa-folder"></i>
              </span>
              <span class="post-meta-item-text">分类于</span>
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/C/" itemprop="url" rel="index"><span itemprop="name">C++</span></a>
                </span>
            </span>

          

        </div>
      </header>

    
    
    
    <div class="post-body" itemprop="articleBody">

      
        <h2 id="输入和输出">输入和输出</h2>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">int i;</span><br><span class="line">float f;</span><br><span class="line">cin &gt;&gt; i;</span><br><span class="line">cout &lt;&lt; f;</span><br><span class="line">------------</span><br><span class="line">scanf(&quot;%d&quot;, &amp;i);</span><br><span class="line">printf(&quot;%f&quot;, f);</span><br><span class="line">----------------</span><br><span class="line">连续读入</span><br><span class="line">cin &gt;&gt; a &gt;&gt; b &gt;&gt; c;</span><br></pre></td></tr></table></figure>
<h3 id="cin">cin</h3>
<p>1.在默认情况下，运算符“&gt;&gt;”将<strong>跳过空白符</strong>，然后读入后面与变量类型相对应的值。因此，给一组变量输入值时可用空格符、回车符、制表符将输入的数据间隔开。</p>
<p>2.当输入字符串（即类型为<strong>string</strong>的变量）时，提取运算符“&gt;&gt;”的作用是跳过空白字符，读入后面的非空白字符，直到遇到另一个空白字符为止，<strong>并在串尾放一个字符串结束标志‘\0’</strong>*。</p>
<h2 id="const">const</h2>
<h3 id="修饰变量">1.修饰变量</h3>
<p>在C语言中，习惯使用#define来定义常量，例如#define PI
3.14，C++提供了一种更灵活、更安全的方式来定义常量，即使用const修饰符来定义常量。例如const
float PI = 3.14；</p>
<h3 id="修饰指针">2.修饰指针</h3>
<p>const可以与指针一起使用，它们的组合情况复杂，可归纳为3种：指向常量的指针、常指针和指向常量的常指针。</p>
<h4
id="指向常量的指针一个指向常量的指针变量">指向常量的指针：一个指向常量的指针变量。</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const char* pc = &quot;abcd&quot;;</span><br><span class="line">该方法不允许改变指针所指的变量，即</span><br><span class="line">    pc[3] = ‘x&#x27;;   是错误的，</span><br><span class="line">但是，由于pc是一个指向常量的普通指针变量，不是常指针，因此可以改变pc所指的地址，例如</span><br><span class="line">    pc = &quot;ervfs&quot;;</span><br><span class="line">该语句付给了指针另一个字符串的地址，改变了pc的值。</span><br></pre></td></tr></table></figure>
<h4
id="常指针将指针变量所指的地址声明为常量">常指针：将指针变量所指的地址声明为常量</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">char* const pc = &quot;abcd&quot;;</span><br><span class="line">创建一个常指针，一个不能移动的固定指针，可更改内容，如</span><br><span class="line">    pc[3] = &#x27;x&#x27;;</span><br><span class="line">但不能改变地址，如</span><br><span class="line">    pc = &#x27;dsff&#x27;;  不合法</span><br></pre></td></tr></table></figure>
<h4
id="指向常量的常指针这个指针所指的地址不能改变它所指向的地址中的内容也不能改变">指向常量的常指针：这个指针所指的地址不能改变，它所指向的地址中的内容也不能改变。</h4>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const char* const pc = &quot;abcd&quot;;</span><br><span class="line">内容和地址均不能改变</span><br></pre></td></tr></table></figure>
<h4 id="说明">说明</h4>
<pre><code>如果用const定义整型常量，关键字可以省略。即 const int bufsize = 100 与 

const bufsize = 100等价；

常量一旦被建立，在程序的任何地方都不能再更改。

与#define不同，const定义的常量可以有自己的数据类型。

函数参数也可以用const说明，用于保证实参在该函数内不被改动。</code></pre>
<h4 id="void型指针">void型指针</h4>
<pre><code>任何类型的指针值都可以赋给void类型的指针变量。

需要指出的是，这里说void型指针是通用指针，是指它可以接受任何类型的指针的赋值，

但对已获值的void型指针，**对它进行再处理**，如输出或者传递指针值时，则必须再进

行显式类型转换，否则会出错。</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">   void* pc;</span><br><span class="line">   int i = 123;</span><br><span class="line">   char c = &#x27;a&#x27;;</span><br><span class="line">   pc = &amp;i;</span><br><span class="line">cout &lt;&lt; pc &lt;&lt; endl;         //输出指针地址006FF730</span><br><span class="line">cout &lt;&lt; *(int*)pc &lt;&lt; endl;  //输出值123</span><br><span class="line">   pc = &amp;c;</span><br><span class="line">cout &lt;&lt; *(char*)pc &lt;&lt; endl; //输出值a</span><br></pre></td></tr></table></figure>
<h2 id="内联函数">内联函数</h2>
<pre><code>C语言程序在运行过程中会遇到很多的函数，当遇到普通的函数的时候，就会生成一个空间

给函数体和函数包含的参数，但是这个对于一些较小的函数而言，这样十分的浪费，因而，

出现了不需要开辟空间给函数体和其包含的参数的函数——内联函数。</code></pre>
<h3 id="注意">注意</h3>
<pre><code>1.在内联函数体内一般不能含有复杂的控制语句，如for语句和switch语句等

2.使用内联函数是一种空间换时间的措施，若内联函数较长，较复杂且调用较为频繁时不建使用</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"> </span><br><span class="line">//内联函数，交换两个数的值</span><br><span class="line">inline void swap(int *a, int *b)</span><br><span class="line">&#123;</span><br><span class="line">    int temp;</span><br><span class="line">    temp = *a;</span><br><span class="line">    *a = *b;</span><br><span class="line">    *b = temp;</span><br><span class="line">&#125;</span><br><span class="line"> </span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">    int m, n;</span><br><span class="line">    cin&gt;&gt;m&gt;&gt;n;</span><br><span class="line">    cout&lt;&lt;m&lt;&lt;&quot;, &quot;&lt;&lt;n&lt;&lt;endl;</span><br><span class="line">    swap(&amp;m, &amp;n);</span><br><span class="line">    cout&lt;&lt;m&lt;&lt;&quot;, &quot;&lt;&lt;n&lt;&lt;endl;</span><br><span class="line"> </span><br><span class="line">    return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<pre><code>//运行结果：
//45 99
//45, 99
//99, 45</code></pre>
<p>注意，要在函数定义处添加 inline 关键字，在函数声明处添加 inline
关键字虽然没有错，但这种做法是无效的，编译器会忽略函数声明处的 inline
关键字。</p>
<p>当编译器遇到函数调用swap(&amp;m, &amp;n)时，会用 swap()
函数的代码替换swap(&amp;m,
&amp;n)，同时用实参代替形参，以下为替换后的结果： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">int temp;</span><br><span class="line">temp = *(&amp;m);</span><br><span class="line">*(&amp;m) = *(&amp;n);</span><br><span class="line">*(&amp;n) = temp;</span><br></pre></td></tr></table></figure>
编译器可能会将 <em>(&amp;m)、</em>(&amp;n) 分别优化为 m、n。</p>
<p>当函数比较复杂时，函数调用的时空开销可以忽略，大部分的 CPU
时间都会花费在执行函数体代码上，所以我们一般是将非常短小的函数声明为内联函数。</p>
<h2 id="带有默认参数值的函数覆盖">带有默认参数值的函数(覆盖)</h2>
<p>当进行函数调用时，编译器按从左到右的顺序将实参与形参结合，若未指定足够的实参，则编译器按顺序用函数原型中的默认值来补足所缺少的实参。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">void init(int x = 5, int y = 10);</span><br><span class="line">init (100, 19);   // 100 ， 19</span><br><span class="line">init(25);         // 25, 10</span><br><span class="line">init();           // 5， 10</span><br></pre></td></tr></table></figure></p>
<h2 id="作用域标识符">作用域标识符"::"</h2>
<p>通常情况下，如果有两个同名变量，一个是全局的，另一个是局部的，那么局部变量在其作用域内具有较高的优先权，它将屏蔽全局变量。</p>
<p>如果希望在局部变量的作用域内使用同名的全局变量，可以在该变量前加上“::”，此时::value代表全局变量value，“::”称为作用域标识符。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int value;   //定义全局变量value</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	int value;  //定义局部变量value</span><br><span class="line">	value = 100;</span><br><span class="line">	::value = 1000;</span><br><span class="line">	cout &lt;&lt; &quot;local value : &quot; &lt;&lt; value &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;global value : &quot; &lt;&lt; ::value &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## new和delete运算符
1.用运算符new分配的空间，使用结束后应该用也只能用delete显式地释放，否则这部分空间将不能回收而变成死空间。</p>
<p>2.在使用运算符new动态分配内存时，如果没有足够的内存满足分配要求，new将返回空指针（NULL）。</p>
<p>3.使用运算符new可以为数组动态分配内存空间，这时需要在类型后面加上数组大小。</p>
<pre><code>指针变量名 = new 类型名[下标表达式];
    int *p = new int[10];</code></pre>
<p>释放动态分配的数组存储区时，可使用delete运算符。</p>
<pre><code>delete []指针变量名;
delete p;</code></pre>
<p>new 可在为简单变量分配空间的同时，进行初始化</p>
<pre><code>指针变量名 = new 类型名(初值);
int *p;
p = new int(99);
···
delete p;</code></pre>
<h2
id="引用在左边是别名在右边是指针">引用（&amp;在左边是别名，在右边是指针）</h2>
<p>引用（reference）是C++对C的一个重要扩充。变量的引用就是变量的别名，因此引用又称别名。</p>
<pre><code>类型 &amp;引用名 = 已定义的变量名</code></pre>
<p>引用与其所代表的变量共享同一内存单元，系统并不为引用另外分配存储空间。实际上，编译系统使引用和其代表的变量具有相同的地址。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	int i = 10;</span><br><span class="line">	int &amp;j = i;</span><br><span class="line">	cout &lt;&lt; &quot;i = &quot; &lt;&lt; i &lt;&lt; &quot; j = &quot; &lt;&lt; j &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;i的地址为 &quot; &lt;&lt; &amp;i &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;j的地址为 &quot; &lt;&lt; &amp;j &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<p>上面代码输出i和j的值相同，地址也相同。</p>
<pre><code>引用并不是一种独立的数据类型，它必须与某一种类型的变量相联系。在声明引用时，必须

立即对它进行初始化，不能声明完成后再赋值。

为引用提供的初始值，可以是一个变量或者另一个引用。

指针是通过地址间接访问某个变量，而引用则是通过别名直接访问某个变量。</code></pre>
<p>引用作为函数参数、使用引用返回函数值 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">void swap(int &amp;a, int &amp;b)</span><br><span class="line">&#123;</span><br><span class="line">	int t = a;</span><br><span class="line">	a = b;</span><br><span class="line">	b = t;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int a[] = &#123;1, 3, 5, 7, 9&#125;;</span><br><span class="line"></span><br><span class="line">int&amp; index(int i)</span><br><span class="line">//用引用返回一个函数值，在内存中不产生被返回值的副本</span><br><span class="line">&#123;</span><br><span class="line">	return a[i];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() </span><br><span class="line">&#123;</span><br><span class="line">	int a = 5, b = 10;</span><br><span class="line">	//交换数字a和b</span><br><span class="line">	swap(a, b);</span><br><span class="line">	cout &lt;&lt; &quot;a = &quot; &lt;&lt; a &lt;&lt; &quot; b = &quot; &lt;&lt; b &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; index(2) &lt;&lt; endl;   //等价于输出元素a[2]的值</span><br><span class="line">	index(2) = 100;             //等价于将a[2]的值赋为100;</span><br><span class="line">	cout &lt;&lt; index(2) &lt;&lt; endl;</span><br><span class="line">	</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure>
对引用的进一步说明</p>
<pre><code>1.不允许建立void类型的引用
2.不能建立引用的数组
3.不能建立引用的引用。不能建立指向引用的指针。引用本身不是一种数据类型，所以没有

4.引用的引用，也没有引用的指针。
5.可以将引用的地址赋值给一个指针，此时指针指向的是原来的变量。
6.可以用const对引用加以限定，不允许改变该引用的值，但是它不阻止引用所代表的变量

 的值。
7.用引用返回一个函数值的最大好处是，在内存中不产生被返回值的副本。</code></pre>
<h2 id="类">类</h2>
<h3 id="类的定义">1.类的定义</h3>
<p>类声明中的内容包括数据和函数，分别称为数据成员和成员函数。按访问权限划分，数据成员和成员函数又可分为共有、保护和私有3种。</p>
<p>class 类名{ public： 公有数据成员； 公有成员函数； protected:
保护数据成员； 保护成员函数； private: 私有数据成员； 私有成员函数；
};</p>
<p>如成绩类 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Score&#123;</span><br><span class="line">    public:</span><br><span class="line">    void setScore(int m, int f);</span><br><span class="line">    void showScore();</span><br><span class="line">    private:</span><br><span class="line">    int mid_exam;</span><br><span class="line">    int fin_exam;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<pre><code>对一个具体的类来讲，类声明格式中的3个部分并非一定要全有，但至少要有其中的一个部

分。一般情况下，一个类的数据成员应该声明为私有成员，成员函数声明为共有成员。这

样，内部的数据整个隐蔽在类中，在类的外部根本就无法看到，使数据得到有效的保护，也

不会对该类以外的其余部分造成影响，程序之间的相互作用就被降低到最小。

类声明中的关键字private、protected、public可以任意顺序出现。

若私有部分处于类的第一部分时，关键字private可以省略。这样，如果一个类体中没有一

个访问权限关键字，则其中的数据成员和成员函数都默认为私有的。

不能在类声明中给数据成员赋初值。</code></pre>
<h4 id="成员函数的定义">1.成员函数的定义</h4>
<h5 id="普通成员函数的定义">1.普通成员函数的定义</h5>
<p>在类的声明中只给出成员函数的原型，而成员函数的定义写在类的外部。这种成员函数在类外定义的一般形式是：
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">返回值类型 类名::成员函数名(参数表)&#123;    函数体&#125;</span><br></pre></td></tr></table></figure></p>
<p>例如，表示分数的类Score可声明如下： <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Score&#123;</span><br><span class="line">public:</span><br><span class="line">	void setScore(int m, int f);</span><br><span class="line">	void showScore();</span><br><span class="line">private:</span><br><span class="line">	int mid_exam;</span><br><span class="line">	int fin_exam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Score::setScore(int m, int f) </span><br><span class="line">&#123;</span><br><span class="line">	mid_exam = m;</span><br><span class="line">	fin_exam = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Score::showScore()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;期中成绩: &quot; &lt;&lt; mid_exam &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;期末成绩：&quot; &lt;&lt; fin_exam &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> #####
2.内联成员函数的定义</p>
<pre><code>隐式声明：将成员函数直接定义在类的内部</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Score&#123;</span><br><span class="line">public:</span><br><span class="line">	void setScore(int m, int f)</span><br><span class="line">	&#123;</span><br><span class="line">		mid_exam = m;</span><br><span class="line">		fin_exam = f;</span><br><span class="line">	&#125;</span><br><span class="line">	void showScore()</span><br><span class="line">	&#123;</span><br><span class="line">		cout &lt;&lt; &quot;期中成绩: &quot; &lt;&lt; mid_exam &lt;&lt; endl;</span><br><span class="line">		cout &lt;&lt; &quot;期末成绩：&quot; &lt;&lt; fin_exam &lt;&lt; endl;</span><br><span class="line">	&#125;</span><br><span class="line">private:</span><br><span class="line">	int mid_exam;</span><br><span class="line">	int fin_exam;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h5
id="显式声明在类声明中只给出成员函数的原型而将成员函数的定义放在类的外部">3.显式声明：在类声明中只给出成员函数的原型，而将成员函数的定义放在类的外部。</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">class Score&#123;</span><br><span class="line">public:</span><br><span class="line">	inline void setScore(int m, int f);</span><br><span class="line">	inline void showScore();</span><br><span class="line">private:</span><br><span class="line">	int mid_exam;</span><br><span class="line">	int fin_exam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">inline void Score::setScore(int m, int f) </span><br><span class="line">&#123;</span><br><span class="line">	mid_exam = m;</span><br><span class="line">	fin_exam = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">inline void Score::showScore()</span><br><span class="line">&#123;</span><br><span class="line">	cout &lt;&lt; &quot;期中成绩: &quot; &lt;&lt; mid_exam &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;期末成绩：&quot; &lt;&lt; fin_exam &lt;&lt; endl;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>说明：在类中，使用inline定义内联函数时，必须将类的声明和内联成员函数的定义都放在同一个文件（或同一个头文件）中，否则编译时无法进行代码置换。
### 2.类和对象 #### 对象的定义</p>
<h5 id="在声明类的同时直接定义对象">1.在声明类的同时，直接定义对象</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class Score&#123;</span><br><span class="line">public:</span><br><span class="line">	void setScore(int m, int f);</span><br><span class="line">	void showScore();</span><br><span class="line">private:</span><br><span class="line">	int mid_exam;</span><br><span class="line">	int fin_exam;</span><br><span class="line">&#125;op1, op2;</span><br></pre></td></tr></table></figure>
<h5
id="声明了类之后在使用时再定义对象">2.声明了类之后，在使用时再定义对象</h5>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score op1, op2;</span><br></pre></td></tr></table></figure>
<p>对象中成员的访问 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">对象名.数据成员名对象名.成员函数名[(参数表)]</span><br><span class="line">op1.setScore(89, 99);</span><br><span class="line">op1.showScore();</span><br></pre></td></tr></table></figure> #### 对象的指针访问时需要用-&gt;
在定义对象时，若定义的是指向此对象的指针变量，则访问此对象的成员时，不能用“.”操作符，而应该使用“-&gt;“操作符。如</p>
<pre><code>Score op, *sc;
sc = &amp;op;
sc-&gt;setScore(99, 100);
op.showScore();</code></pre>
<h4 id="对象赋值语句">对象赋值语句</h4>
<p>//这里会调用赋值函数</p>
<pre><code>Score op1, op2;
op1.setScore(99, 100);
op2 = op1;
op2.showScore();</code></pre>
<p>​</p>
<h2 id="构造造函数">构造造函数</h2>
<h3 id="普通的构造函数">1.普通的构造函数</h3>
<pre><code>    构造函数是一种特殊的成员函数，它主要用于为对象分配空间，进行初始化。构造函数的名字必须与类名相同，而不能由用户任意命名。它可以有任意类型的参数，但不能具有返回值。它不需要用户来调用，而是在建立对象时自动执行。
    
    构造函数的名字必须与类名相同，否则编译程序将把它当做一般的成员函数来处理。
    构造函数没有返回值，在定义构造函数时，是不能说明它的类型的。
    与普通的成员函数一样，构造函数的函数体可以写在类体内，也可写在类体外。
    构造函数一般声明为共有成员，但它不需要也不能像其他成员函数那样被显式地调用，它是在定义对象的同时被自动调用，而且只执行一次。
    构造函数可以不带参数。</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">private:</span><br><span class="line">  int n,m;</span><br><span class="line">public:</span><br><span class="line">  num(int a,int b);</span><br><span class="line">  void show();</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">// num ::num(int a,int b)</span><br><span class="line">// &#123;</span><br><span class="line">//   n=a;</span><br><span class="line">//   m=b;</span><br><span class="line">// &#125;</span><br></pre></td></tr></table></figure>
<h3 id="初始化列表构造函数">2.初始化列表构造函数</h3>
<p>成员初始化列表： 成员变量（参数1），成员变量（参数2），.....
<em>记住</em>之间是 ‘ ，’ <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">类名::构造函数名([参数表])[:(成员初始化列表)]</span><br><span class="line">&#123;</span><br><span class="line">    //构造函数体</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"> num:: num(int a,int b):n(a),m(b)</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;&quot;正在构造... &quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ## 析构函数
析构函数也是一种特殊的成员函数。它执行与构造函数相反的操作，通常用于撤销对象时的一些清理任务，如释放分配给对象的内存空间等。析构函数有以下一些特点：</p>
<pre><code>1.析构函数与构造函数名字相同，但它前面必须加一个波浪号（~）。
2.析构函数没有参数和返回值，也不能被重载，因此只有一个。
3.当撤销对象时，编译系统会自动调用析构函数。</code></pre>
<p>一下情况析构函数会被自动调用</p>
<pre><code>1.如果定义了一个全局对象，则在程序流程离开其作用域时，调用该全局对象的析构函数。
2.如果一个对象定义在一个函数体内，则当这个函数被调用结束时，该对象应该被释放，析构函数被自动调用。
3.若一个对象是使用new运算符创建的，在使用delete运算符释放它时，delete会自动调用析构函数。</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">public:</span><br><span class="line">  ~num();</span><br><span class="line">  num(int a,int b);</span><br><span class="line">  void show();</span><br><span class="line">&#125;;</span><br><span class="line">num::~num()</span><br><span class="line">&#123;</span><br><span class="line">  cout&lt;&lt;&quot;正在删除该对象&quot;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="默认的构造函数和析构函数">默认的构造函数和析构函数</h3>
<p>如果没有给类定义构造函数，则编译系统自动生成一个默认的构造函数。</p>
<p>说明：</p>
<p>1.对没有定义构造函数的类，其公有数据成员可以用初始值列表进行初始化,但是只有共有的数据，因而默认析构的没法访问私有变量。</p>
<p>2.只要一个类定义了一个构造函数（不一定是无参构造函数），系统将不再给它提供默认构造函数。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">class A&#123;</span><br><span class="line">public:</span><br><span class="line">	char name[10];</span><br><span class="line">	int no;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">A a = &#123;&quot;chen&quot;, 23&#125;;</span><br><span class="line">cout &lt;&lt; a.name &lt;&lt; a.no &lt;&lt; endl;</span><br></pre></td></tr></table></figure> ## 拷贝构造函数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line">类名::类名(const 类名 &amp;对象名) </span><br><span class="line">&#123;</span><br><span class="line">    拷贝构造函数的函数体；</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">class Score&#123;</span><br><span class="line">public:</span><br><span class="line">	Score(int m, int f);  //构造函数</span><br><span class="line">	Score();</span><br><span class="line">	Score(const Score &amp;p);  //拷贝构造函数</span><br><span class="line">	~Score();               //析构函数</span><br><span class="line">	void setScore(int m, int f);</span><br><span class="line">	void showScore();</span><br><span class="line">private:</span><br><span class="line">	int mid_exam;</span><br><span class="line">	int fin_exam;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Score::Score(int m, int f)</span><br><span class="line">&#123;</span><br><span class="line">	mid_exam = m;</span><br><span class="line">	fin_exam = f;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Score::Score(const Score &amp;p)</span><br><span class="line">&#123;</span><br><span class="line">	mid_exam = p.mid_exam;</span><br><span class="line">	fin_exam = p.fin_exam;</span><br><span class="line">&#125;</span><br><span class="line">//这里p代表的是被拷贝的对象</span><br><span class="line">调用拷贝构造函数的一般形式为：</span><br><span class="line">    类名 对象2(对象1);</span><br><span class="line">    类名 对象2 = 对象1;</span><br><span class="line">Score sc1(98, 87);</span><br><span class="line">Score sc2(sc1);    //调用拷贝构造函数</span><br><span class="line">Score sc3 = sc2;   //调用拷贝构造函数</span><br></pre></td></tr></table></figure>
当用类的一个对象去初始化该类的另一个对象时；
当函数的形参是类的对象，调用函数进行形参和实参结合时；
当函数的返回值是对象，函数执行完成返回调用者时。 浅拷贝和深拷贝
浅拷贝，就是由默认的拷贝构造函数所实现的数据成员逐一赋值。通常默认的拷贝构造函数是能够胜任此工作的，但若类中含有指针类型的数据，则这种按数据成员逐一赋值的方法会产生错误。</p>
<p>class Student{ public: Student(char <em>name1, float score1);
~Student(); private: char </em>name; float score; };</p>
<p>如下语句会产生错误 Student stu1("白", 89); Student stu2 = stu1;</p>
<p>上述错误是因为stu1和stu2所指的内存空间相同，在析构函数释放stu1所指的内存后，再释放stu2所指的内存会发生错误，因为此内存空间已被释放。解决方法就是重定义拷贝构造函数，为其变量重新生成内存空间。</p>
<pre><code>       **这里p代表的是被拷贝的对象**</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">Student::Student(const Student&amp; p)</span><br><span class="line">&#123;</span><br><span class="line">    name = new char[strlen(p.name) + 1];</span><br><span class="line">    if (name != 0) &#123;</span><br><span class="line">        strcpy(name, p.name);</span><br><span class="line">        score = p.score;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="自引指针">自引指针</h2>
<p>this指针保存当前对象的地址，称为自引用指针</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class Node</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	double x_;</span><br><span class="line">	double y_;</span><br><span class="line">public:</span><br><span class="line">	Node(double x=0,double y=0)</span><br><span class="line">	&#123; x_=x;y_=y; &#125;</span><br><span class="line">	void copy(Node&amp; node);  </span><br><span class="line">	void disp(void)</span><br><span class="line">	&#123; cout&lt;&lt;&quot;\nthis=&quot;&lt;&lt;this&lt;&lt;&quot;when x_=&quot;&lt;&lt;this-&gt;x_; &#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Node nod1(1,2),nod2;</span><br><span class="line">	nod1.disp();//将this在nod1中的状态输出</span><br><span class="line">	</span><br><span class="line">	nod2.disp();//将this在nod1中的状态输出</span><br><span class="line">	cout&lt;&lt;&quot;\n&quot;;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="对象数组">对象数组</h2>
<p>类名 数组名[下标表达式]</p>
<p>用只有一个参数的构造函数给对象数组赋值 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exam ob[4] = &#123;89, 97, 79, 88&#125;;</span><br></pre></td></tr></table></figure>
用不带参数和带一个参数的构造函数给对象数组赋值 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Exam ob[4] = &#123;89, 90&#125;;</span><br></pre></td></tr></table></figure>
用带有多个参数的构造函数给对象数组赋值 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Score rec[3] = &#123;Score(33, 99), Score(87, 78), Score(99, 100)&#125;;</span><br></pre></td></tr></table></figure> <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class one</span><br><span class="line">&#123;</span><br><span class="line">private:</span><br><span class="line">	int a;</span><br><span class="line">public:</span><br><span class="line">	one(int a_):a(a_)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	void show()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">class two</span><br><span class="line">&#123;</span><br><span class="line">	private:</span><br><span class="line">		int a;</span><br><span class="line">		int b;</span><br><span class="line">public:</span><br><span class="line">	two(int a_,int b_):a(a_),b(b_)</span><br><span class="line">	&#123;</span><br><span class="line">	&#125;</span><br><span class="line">	void show()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;a&lt;&lt;&quot; &quot;&lt;&lt;b&lt;&lt;&quot; &quot;;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	one as[3]=&#123;1,2,3&#125;;</span><br><span class="line">	int i=0;</span><br><span class="line">	for(;i&lt;3;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		as[i].show();</span><br><span class="line">	&#125;</span><br><span class="line">	two bs[3]=&#123;two(1,1),two(2,2),two(3,3)&#125;;</span><br><span class="line">	i=0;</span><br><span class="line">	for(;i&lt;3;i++)</span><br><span class="line">	&#123;</span><br><span class="line">		bs[i].show();</span><br><span class="line">	&#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="string类">string类</h2>
<p>C++支持两种类型的字符串，第一种是C语言中介绍过的、包括一个结束符’\0’（即以NULL结束）的字符数组，标准库函数提供了一组对其进行操作的函数，可以完成许多常用的字符串操作。</p>
<p>C++标准库中声明了一种更方便的字符串类型，即字符串类string，类string提供了对字符串进行处理所需要的操作。使用string类必须在程序的开始包括头文件string，即要有以下语句：#include
<string> 注意：string不是string.h 常用的：</p>
<p>=（”“）、
=、+、+=、==、!=、&lt;、&lt;=、&gt;、&gt;=、[]（访问下标对应字符）、&gt;&gt;（输入）、&lt;&lt;（输出）
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	string str1 = &quot;ABC&quot;;</span><br><span class="line">	string str2(&quot;dfdf&quot;);</span><br><span class="line">	string str3 = str1 + str2;</span><br><span class="line">	cout&lt;&lt; &quot;str1 = &quot; &lt;&lt; str1 &lt;&lt; &quot;  str2 = &quot; &lt;&lt; str2 &lt;&lt; &quot;  str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	str2 += str2;</span><br><span class="line">	str3 += &quot;aff&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;str2 = &quot; &lt;&lt; str2 &lt;&lt; &quot;  str3 = &quot; &lt;&lt; str3 &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;str1[1] = &quot; &lt;&lt; str1[1] &lt;&lt; &quot;  str1 == str2 ? &quot; &lt;&lt; (str1 == str2) &lt;&lt; endl;</span><br><span class="line">	string str = &quot;ABC&quot;;</span><br><span class="line">	cout &lt;&lt; &quot;str == str1 ? &quot; &lt;&lt; (str == str1) &lt;&lt; endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 对象和对象指针以及对象引用传递参数 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Point&#123;</span><br><span class="line">public:</span><br><span class="line">	int x;</span><br><span class="line">	int y;</span><br><span class="line">	Point(int x1, int y1) : x(x1), y(y1)  //成员初始化列表</span><br><span class="line">    &#123; &#125;</span><br><span class="line">	int getDistance() </span><br><span class="line">	&#123;</span><br><span class="line">		return x * x + y * y;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void changePoint1(Point point)    //使用对象作为函数参数</span><br><span class="line">&#123;</span><br><span class="line">	point.x += 1;</span><br><span class="line">	point.y -= 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void changePoint2(Point *point)   //使用对象指针作为函数参数</span><br><span class="line">&#123;</span><br><span class="line">	point-&gt;x += 1;</span><br><span class="line">	point-&gt;y -= 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void changePoint3(Point &amp;point)  //使用对象引用作为函数参数</span><br><span class="line">&#123;</span><br><span class="line">	point.x += 1;</span><br><span class="line">	point.y -= 1;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Point point[3] = &#123;Point(1, 1), Point(2, 2), Point(3, 3)&#125;;</span><br><span class="line">	Point *p = point;</span><br><span class="line">	changePoint1(*p);</span><br><span class="line">	cout &lt;&lt; &quot;the distance is &quot; &lt;&lt; p[0].getDistance() &lt;&lt; endl;</span><br><span class="line">	p++;</span><br><span class="line">	changePoint2(p);</span><br><span class="line">	cout &lt;&lt; &quot;the distance is &quot; &lt;&lt; p-&gt;getDistance() &lt;&lt; endl;</span><br><span class="line">	changePoint3(point[2]);</span><br><span class="line">	cout &lt;&lt; &quot;the distance is &quot; &lt;&lt; point[2].getDistance() &lt;&lt; endl;</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="静态成员">静态成员</h2>
<p>在一个类中，若将一个数据成员说明为static，则这种成员被称为静态数据成员。与一般的数据成员不同，无论建立多少个类的对象，都只有一个静态数据成员的拷贝。从而实现了同一个类的不同对象之间的数据共享。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">定义静态数据成员的格式如下：static 数据类型 数据成员名;</span><br></pre></td></tr></table></figure>
1.静态数据成员的初始化与普通数据成员不同。静态数据成员初始化应在类外单独进行，而且应在定义对象之前进行。一般在main()函数之前、类声明之后的特殊地带为它提供定义和初始化。</p>
<p>2.静态数据成员属于类（准确地说，是属于类中对象的集合），而不像普通数据成员那样属于某一对象，因此，可以使用“类名::”访问静态的数据成员。格式如下：类名::静态数据成员名。</p>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">	static int a;//静态成员变量不能在内部被初始化</span><br><span class="line">public :</span><br><span class="line">	void check()</span><br><span class="line">	&#123;</span><br><span class="line">		a++;</span><br><span class="line">		cout &lt;&lt;a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> int A::a=1;//在初始化的时候，数据类（int）不能忘记</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A b;</span><br><span class="line">	b.check();//2</span><br><span class="line">	A c;</span><br><span class="line">	c.check();//3	</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>3.当静态成员变量被public修饰后，可以不依赖对象直接进行访问，访问格式：类名::静态成员变量名。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">	</span><br><span class="line">public :</span><br><span class="line">	static int a;</span><br><span class="line">	void check()</span><br><span class="line">	&#123;</span><br><span class="line">		a++;</span><br><span class="line">		cout &lt;&lt;a;</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"> int A::a=1;//在初始化的时候，数据类（int）不能忘记</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	A::a++;</span><br><span class="line">	A c;</span><br><span class="line">	c.check();//3</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 静态成员函数
4.类的静态成员函数只能访问类的静态成员变量，因为非静态成员变量只有对象存在才有意义。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">#include&lt;iostream&gt;</span><br><span class="line">using namespace std;</span><br><span class="line">class A&#123;</span><br><span class="line">	</span><br><span class="line">public :</span><br><span class="line">	static int a;</span><br><span class="line">	int b;</span><br><span class="line">	static void check()</span><br><span class="line">	&#123;</span><br><span class="line">		</span><br><span class="line">		//cout &lt;&lt;b //报错，静态成员函数只能访问静态成员变量</span><br><span class="line">		cout &lt;&lt;a;</span><br><span class="line">	&#125;</span><br><span class="line">	</span><br><span class="line">&#125;;</span><br><span class="line"> int A::a=1;//在初始化的时候，数据类（int）不能忘记</span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	</span><br><span class="line">	A c&#123;1&#125;;</span><br><span class="line">	c.check();</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
1.使用静态成员函数的一个原因是，可以用它在建立任何对象之前调用静态成员函数，以处理静态数据成员，这是普通成员函数不能实现的功能</p>
<p>2.编译系统将静态成员函数限定为内部连接，也就是说，与现行文件相连接的其他文件中的同名函数不会与该函数发生冲突，维护了该函数使用的安全性，这是使用静态成员函数的另一个原因。(看不明白的话，可以了解一下程序到底是咋运行的，比如
编译，链接)</p>
<p>3.静态成员函数是类的一部分，而不是对象的一部分。如果要在类外调用公有的静态成员函数，使用如下格式较好：类名::静态成员函数名()</p>
<h2 id="友元">友元</h2>
<h3 id="友元函数">友元函数</h3>
<pre><code>友元函数既可以是不属于任何类的非成员函数，也可以是另一个类的成员函数。友元函数不是当前类的成员函数，但它可以访问该类的所有成员，包括私有成员、保护成员和公有成员。
在类中声明友元函数时，需要在其函数名前加上关键字friend。此声明可以放在公有部分，也可以放在保护部分和私有部分。友元函数可以定义在类内部，也可以定义在类外部。友元函数可以在多处声明，形成了每个类之间的联系，在多处声明的时候，不要忘记还未被定义的类也需要声明</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Score;    //对Score类的提前引用说明</span><br><span class="line">class Student&#123;</span><br><span class="line">private:</span><br><span class="line">	string name;</span><br><span class="line">	int number;</span><br><span class="line">public:</span><br><span class="line">	Student(string na, int nu) &#123;</span><br><span class="line">		name = na;</span><br><span class="line">		number = nu;</span><br><span class="line">	&#125;</span><br><span class="line">	friend void show(Score &amp;sc, Student &amp;st);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Score&#123;</span><br><span class="line">private:</span><br><span class="line">	int mid_exam;</span><br><span class="line">	int fin_exam;</span><br><span class="line">public:</span><br><span class="line">	Score(int m, int f) &#123;</span><br><span class="line">		mid_exam = m;</span><br><span class="line">		fin_exam = f;</span><br><span class="line">	&#125;</span><br><span class="line">	friend void show(Score &amp;sc, Student &amp;st);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void show(Score &amp;sc, Student &amp;st) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; st.name &lt;&lt; &quot;  学号：&quot; &lt;&lt; st.number &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;期中成绩：&quot; &lt;&lt; sc.mid_exam &lt;&lt; &quot;  期末成绩：&quot; &lt;&lt; sc.fin_exam &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Score sc(89, 99);</span><br><span class="line">	Student st(&quot;白&quot;, 12467);</span><br><span class="line">	show(sc, st);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3
id="将成员函数声明为友元函数个人认为这个了解就ok没有第一种方便">将成员函数声明为友元函数（个人认为这个了解就ok，没有第一种方便）</h3>
<p>一个类的成员函数可以作为另一个类的友元，它是友元函数中的一种，称为友元成员函数。友元成员函数不仅可以访问自己所在类对象中的私有成员和公有成员，还可以访问friend声明语句所在类对象中的所有成员，这样能使两个类相互合作、协调工作，完成某一任务。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br></pre></td><td class="code"><pre><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;string&gt;</span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Score;    //对Score类的提前引用说明</span><br><span class="line">class Student&#123;</span><br><span class="line">private:</span><br><span class="line">	string name;</span><br><span class="line">	int number;</span><br><span class="line">public:</span><br><span class="line">	Student(string na, int nu) &#123;</span><br><span class="line">		name = na;</span><br><span class="line">		number = nu;</span><br><span class="line">	&#125;</span><br><span class="line">	void show(Score &amp;sc);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Score&#123;</span><br><span class="line">private:</span><br><span class="line">	int mid_exam;</span><br><span class="line">	int fin_exam;</span><br><span class="line">public:</span><br><span class="line">	Score(int m, int f) &#123;</span><br><span class="line">		mid_exam = m;</span><br><span class="line">		fin_exam = f;</span><br><span class="line">	&#125;</span><br><span class="line">	friend void Student::show(Score &amp;sc);</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Student::show(Score &amp;sc) &#123;</span><br><span class="line">	cout &lt;&lt; &quot;姓名：&quot; &lt;&lt; name &lt;&lt; &quot;  学号：&quot; &lt;&lt; number &lt;&lt; endl;</span><br><span class="line">	cout &lt;&lt; &quot;期中成绩：&quot; &lt;&lt; sc.mid_exam &lt;&lt; &quot;  期末成绩：&quot; &lt;&lt; sc.fin_exam &lt;&lt; endl;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main() &#123;</span><br><span class="line">	Score sc(89, 99);</span><br><span class="line">	Student st(&quot;白&quot;, 12467);</span><br><span class="line">	st.show(sc);</span><br><span class="line"></span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> ### 友元类("姐妹")
《windows环境多线程编程原理与应用》中解释： 　
如果将类的封装比喻成一堵墙的话，那么友元机制就像墙上了开了一个门，那些得
　
到允许的类或函数允许通过这个门访问一般的类或者函数无法访问的私有属性和方　　　
　 法。友元机制使类的封装性得到消弱，所以使用时一定要慎重。</p>
<pre><code>   使用友元类时注意：
     (1) 友元关系不能被继承。 
     (2) 友元关系是单向的，不具有交换性。若类B是类A的友元，类A不一定是类B的友元，要看在类中是否有相应的声明。
     (3) 友元关系不具有传递性。若类B是类A的友元，类C是B的友元，类C不一定是类A的友元，同样要看类中是否有相应的申明</code></pre>
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"></span><br></pre></td></tr></table></figure>
<p>可以将一个类声明为另一个类的友元 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">class Y&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;;</span><br><span class="line">class X&#123;</span><br><span class="line">    friend Y;    //声明类Y为类X的友元类</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>当一个类被说明为另一个类的友元类时，它所有的成员函数都成为另一个类的友元函数，这就意味着作为友元类中的所有成员函数都可以访问另一个类中的所有成员。</p>
<p>友元关系不具有交换性和传递性，也就是友元类能访问声明的类，但是声明的类，不能访问友元类。
## 类的组合
在一个类中内嵌另一个类的对象作为数据成员，称为类的组合。该内嵌对象称为对象成员，又称为子对象。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br></pre></td><td class="code"><pre><span class="line">class Y&#123;</span><br><span class="line">    ···</span><br><span class="line">&#125;;</span><br><span class="line">class X&#123;</span><br><span class="line">    Y y;</span><br><span class="line">    ···</span><br><span class="line">&#125;;</span><br><span class="line">#include &lt;iostream&gt;</span><br><span class="line">#include &lt;cmath&gt;</span><br><span class="line"></span><br><span class="line">using namespace std;</span><br><span class="line"></span><br><span class="line">class Point&#123;</span><br><span class="line">private:</span><br><span class="line">	int x,y;</span><br><span class="line">public:</span><br><span class="line">	Point(int px,int py)</span><br><span class="line">	&#123;</span><br><span class="line">		x=px;</span><br><span class="line">		y=py;</span><br><span class="line">		cout&lt;&lt;&quot;Point constructor called&quot;&lt;&lt;endl; //调用的点构造函数 </span><br><span class="line">	&#125;</span><br><span class="line">	Point(const Point&amp; p)</span><br><span class="line">	&#123;</span><br><span class="line">		x=p.x;</span><br><span class="line">		y=p.y;</span><br><span class="line">		cout&lt;&lt;&quot;Point copy constructor called&quot;&lt;&lt;endl;  //拷贝函数 </span><br><span class="line">	&#125;</span><br><span class="line">	~Point()	&#123;	cout&lt;&lt;&quot;Point destructor called&quot;&lt;&lt;endl;	&#125;		</span><br><span class="line">	int getx()	&#123;	return x;	&#125;</span><br><span class="line">	int gety()	&#123;	return y;	&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">class Line&#123;</span><br><span class="line">private:</span><br><span class="line">	//这里体现了类的组合：即Line类中的数据成员是另一个Point类的对象。</span><br><span class="line">	//通过类的组合在已有的点抽象的基础上实现了更复杂的线段抽象。 </span><br><span class="line">	Point p1,p2;  //定义了点对象p1,p2为它的私有数据成员，得以访问点对象中的成员 </span><br><span class="line">	double len;</span><br><span class="line">public:</span><br><span class="line">	//线段需要两个点构成，传入点对象xp1,xp2。并将它们保存到线段类的数据成员中 </span><br><span class="line">	Line(const Point&amp; xp1,const Point&amp; xp2);  //线段复制构造函数 </span><br><span class="line">	~Line()		&#123;	cout&lt;&lt;&quot;Line destructor called&quot;&lt;&lt;endl;	&#125;</span><br><span class="line">	double getLen()	&#123;return len;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Line::Line(const Point&amp; xp1,const Point&amp; xp2):p1(xp1),p2(xp2)</span><br><span class="line">&#123;</span><br><span class="line">	double x=p1.getx()-p2.getx();</span><br><span class="line">	double y=p1.gety()-p2.gety();</span><br><span class="line">	len=sqrt(x*x+y*y);</span><br><span class="line">	cout&lt;&lt;&quot;Line constructor called&quot;&lt;&lt;endl;  //调用的线段复制构造函数 </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">int main()</span><br><span class="line">&#123;</span><br><span class="line">	Point pa(3,4),pb(10,9);</span><br><span class="line">	Line L1(pa,pb);</span><br><span class="line">	cout&lt;&lt;&quot;L1 start point:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;pa.getx()&lt;&lt;&quot;,&quot;&lt;&lt;pa.gety()&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;L1 end point:&quot;&lt;&lt;&quot;(&quot;&lt;&lt;pb.getx()&lt;&lt;&quot;,&quot;&lt;&lt;pb.gety()&lt;&lt;&quot;)&quot;&lt;&lt;endl;</span><br><span class="line">	cout&lt;&lt;&quot;The length of L1 is:&quot;&lt;&lt;L1.getLen()&lt;&lt;endl;</span><br><span class="line">	return 0;</span><br><span class="line">&#125;</span><br><span class="line"></span><br></pre></td></tr></table></figure></p>
<h2 id="常引用">常引用</h2>
<p>常类型是指使用类型修饰符const说明的类型，常类型的变量或对象成员的值在程序（注意生存周期）运行期间是不可改变的。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">int a = 5;</span><br><span class="line">const int&amp; b = a;</span><br><span class="line">此时再对b赋值是非法的。</span><br><span class="line">---------------------------</span><br><span class="line">int add(const int&amp; m, const int&amp; n) &#123;</span><br><span class="line">    return m + n;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure> 在此函数中对变量m和变量n更新时非法的 ## 常对象</p>
<p>如果在说明对象时用const修饰，则被说明的对象为常对象。常对象中的数据成员为常量且必须要有初值。</p>
<p>类名 const 对象名[(参数表)]; <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const Date date(2021, 5, 31);</span><br></pre></td></tr></table></figure> ## 常对象成员
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Date&#123;</span><br><span class="line">private:</span><br><span class="line">	const int year;</span><br><span class="line">	const int month;</span><br><span class="line">	const int day;</span><br><span class="line">public:</span><br><span class="line">	Date(int y, int m, int d) : year(y), month(m), day(d) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	show()</span><br><span class="line">	&#123;</span><br><span class="line">		cout&lt;&lt;year;//非法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> 1.只能被构造函数中的列表赋值</p>
<p>2.没法被别的函数赋值</p>
<p>3.不能被更改 <figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">class Date&#123;</span><br><span class="line">private:</span><br><span class="line">	const int year;</span><br><span class="line">	const int month;</span><br><span class="line">	const int day;</span><br><span class="line">public:</span><br><span class="line">	Date(int y, int m, int d) : year(y), month(m), day(d) &#123;</span><br><span class="line">		</span><br><span class="line">	&#125;</span><br><span class="line">	void show()</span><br><span class="line">	&#123;</span><br><span class="line">		year=2023;//非法</span><br><span class="line">	&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure> ## 常成员函数</p>
<p>2、常成员函数</p>
<p>类型 函数名(参数表) const;</p>
<p>const是函数类型的一个组成部分，因此在声明函数和定义函数时都要有关键字const。在调用时不必加const。
<figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">class Date&#123;</span><br><span class="line">private:</span><br><span class="line">	int year;</span><br><span class="line">	int month;</span><br><span class="line">	int day;</span><br><span class="line">public:</span><br><span class="line">	Date(int y, int m, int d) : year(y), month(m), day(d)&#123;</span><br><span class="line"></span><br><span class="line">	&#125;</span><br><span class="line">	void showDate();</span><br><span class="line">	void showDate() const;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">void Date::showDate() &#123;</span><br><span class="line">	//···</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">void Date::showDate() const &#123;</span><br><span class="line">	//···</span><br></pre></td></tr></table></figure> 关键字const可以被用于对重载函数进行区分。</p>
<p>说明：</p>
<p>1.常成员函数可以访问常数据成员，也可以访问普通数据成员。</p>
<p>2.常对象只能调用它的常成员对象，而不能调用普通成员函数。常成员函数是常对象唯一的对外接口。</p>
<p>3.常对象函数不能更新对象的数据成员，也不能调用该类的普通成员函数，这就保证了在常成员函数中绝不会更新数据成员的值</p>

    </div>

    
    
    

      <footer class="post-footer">
          <div class="post-tags">
              <a href="/tags/%E5%9F%BA%E7%A1%80/" rel="tag"># 基础</a>
          </div>

        


        
    <div class="post-nav">
      <div class="post-nav-item">
    <a href="/2022/09/18/%E5%8D%9A%E5%AE%A2%E5%8F%91%E6%96%87%E7%AB%A0%E9%A1%BA%E5%BA%8F/" rel="prev" title="网站发文章顺序">
      <i class="fa fa-chevron-left"></i> 网站发文章顺序
    </a></div>
      <div class="post-nav-item">
    <a href="/2023/08/31/go00/" rel="next" title="第一遍学习go基础">
      第一遍学习go基础 <i class="fa fa-chevron-right"></i>
    </a></div>
    </div>
      </footer>
    
  </article>
  
  
  



          </div>
          

<script>
  window.addEventListener('tabs:register', () => {
    let { activeClass } = CONFIG.comments;
    if (CONFIG.comments.storage) {
      activeClass = localStorage.getItem('comments_active') || activeClass;
    }
    if (activeClass) {
      let activeTab = document.querySelector(`a[href="#comment-${activeClass}"]`);
      if (activeTab) {
        activeTab.click();
      }
    }
  });
  if (CONFIG.comments.storage) {
    window.addEventListener('tabs:click', event => {
      if (!event.target.matches('.tabs-comment .tab-content .tab-pane')) return;
      let commentClass = event.target.classList[1];
      localStorage.setItem('comments_active', commentClass);
    });
  }
</script>

        </div>
          
  
  <div class="toggle sidebar-toggle">
    <span class="toggle-line toggle-line-first"></span>
    <span class="toggle-line toggle-line-middle"></span>
    <span class="toggle-line toggle-line-last"></span>
  </div>

  <aside class="sidebar">
    <div class="sidebar-inner">
    <div>
    <iframe frameborder="no" border="0" marginwidth="0" marginheight="0" width=330 height=450 src="//music.163.com/outchain/player?type=0&id=7575292815&auto=0&height=430"></iframe>
    </div>
      <ul class="sidebar-nav motion-element">
        <li class="sidebar-nav-toc">
          文章目录
        </li>
        <li class="sidebar-nav-overview">
          站点概览
        </li>
      </ul>

      <!--noindex-->
      <div class="post-toc-wrap sidebar-panel">
          <div class="post-toc motion-element"><ol class="nav"><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%BE%93%E5%85%A5%E5%92%8C%E8%BE%93%E5%87%BA"><span class="nav-number">1.</span> <span class="nav-text">输入和输出</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#cin"><span class="nav-number">1.1.</span> <span class="nav-text">cin</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#const"><span class="nav-number">2.</span> <span class="nav-text">const</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E5%8F%98%E9%87%8F"><span class="nav-number">2.1.</span> <span class="nav-text">1.修饰变量</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E4%BF%AE%E9%A5%B0%E6%8C%87%E9%92%88"><span class="nav-number">2.2.</span> <span class="nav-text">2.修饰指针</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E4%B8%80%E4%B8%AA%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F"><span class="nav-number">2.2.1.</span> <span class="nav-text">指向常量的指针：一个指向常量的指针变量。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%B8%B8%E6%8C%87%E9%92%88%E5%B0%86%E6%8C%87%E9%92%88%E5%8F%98%E9%87%8F%E6%89%80%E6%8C%87%E7%9A%84%E5%9C%B0%E5%9D%80%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%B8%B8%E9%87%8F"><span class="nav-number">2.2.2.</span> <span class="nav-text">常指针：将指针变量所指的地址声明为常量</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%8C%87%E5%90%91%E5%B8%B8%E9%87%8F%E7%9A%84%E5%B8%B8%E6%8C%87%E9%92%88%E8%BF%99%E4%B8%AA%E6%8C%87%E9%92%88%E6%89%80%E6%8C%87%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%8D%E8%83%BD%E6%94%B9%E5%8F%98%E5%AE%83%E6%89%80%E6%8C%87%E5%90%91%E7%9A%84%E5%9C%B0%E5%9D%80%E4%B8%AD%E7%9A%84%E5%86%85%E5%AE%B9%E4%B9%9F%E4%B8%8D%E8%83%BD%E6%94%B9%E5%8F%98"><span class="nav-number">2.2.3.</span> <span class="nav-text">指向常量的常指针：这个指针所指的地址不能改变，它所指向的地址中的内容也不能改变。</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E8%AF%B4%E6%98%8E"><span class="nav-number">2.2.4.</span> <span class="nav-text">说明</span></a></li><li class="nav-item nav-level-4"><a class="nav-link" href="#void%E5%9E%8B%E6%8C%87%E9%92%88"><span class="nav-number">2.2.5.</span> <span class="nav-text">void型指针</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%86%85%E8%81%94%E5%87%BD%E6%95%B0"><span class="nav-number">3.</span> <span class="nav-text">内联函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%B3%A8%E6%84%8F"><span class="nav-number">3.1.</span> <span class="nav-text">注意</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%A6%E6%9C%89%E9%BB%98%E8%AE%A4%E5%8F%82%E6%95%B0%E5%80%BC%E7%9A%84%E5%87%BD%E6%95%B0%E8%A6%86%E7%9B%96"><span class="nav-number">4.</span> <span class="nav-text">带有默认参数值的函数(覆盖)</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E4%BD%9C%E7%94%A8%E5%9F%9F%E6%A0%87%E8%AF%86%E7%AC%A6"><span class="nav-number">5.</span> <span class="nav-text">作用域标识符&quot;::&quot;</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%BC%95%E7%94%A8%E5%9C%A8%E5%B7%A6%E8%BE%B9%E6%98%AF%E5%88%AB%E5%90%8D%E5%9C%A8%E5%8F%B3%E8%BE%B9%E6%98%AF%E6%8C%87%E9%92%88"><span class="nav-number">6.</span> <span class="nav-text">引用（&amp;在左边是别名，在右边是指针）</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E7%B1%BB"><span class="nav-number">7.</span> <span class="nav-text">类</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E7%B1%BB%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.1.</span> <span class="nav-text">1.类的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-4"><a class="nav-link" href="#%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.1.1.</span> <span class="nav-text">1.成员函数的定义</span></a><ol class="nav-child"><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89"><span class="nav-number">7.1.1.1.</span> <span class="nav-text">1.普通成员函数的定义</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E6%98%BE%E5%BC%8F%E5%A3%B0%E6%98%8E%E5%9C%A8%E7%B1%BB%E5%A3%B0%E6%98%8E%E4%B8%AD%E5%8F%AA%E7%BB%99%E5%87%BA%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%8E%9F%E5%9E%8B%E8%80%8C%E5%B0%86%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E7%9A%84%E5%AE%9A%E4%B9%89%E6%94%BE%E5%9C%A8%E7%B1%BB%E7%9A%84%E5%A4%96%E9%83%A8"><span class="nav-number">7.1.1.2.</span> <span class="nav-text">3.显式声明：在类声明中只给出成员函数的原型，而将成员函数的定义放在类的外部。</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%9C%A8%E5%A3%B0%E6%98%8E%E7%B1%BB%E7%9A%84%E5%90%8C%E6%97%B6%E7%9B%B4%E6%8E%A5%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.1.1.3.</span> <span class="nav-text">1.在声明类的同时，直接定义对象</span></a></li><li class="nav-item nav-level-5"><a class="nav-link" href="#%E5%A3%B0%E6%98%8E%E4%BA%86%E7%B1%BB%E4%B9%8B%E5%90%8E%E5%9C%A8%E4%BD%BF%E7%94%A8%E6%97%B6%E5%86%8D%E5%AE%9A%E4%B9%89%E5%AF%B9%E8%B1%A1"><span class="nav-number">7.1.1.4.</span> <span class="nav-text">2.声明了类之后，在使用时再定义对象</span></a></li></ol></li><li class="nav-item nav-level-4"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E8%B5%8B%E5%80%BC%E8%AF%AD%E5%8F%A5"><span class="nav-number">7.1.2.</span> <span class="nav-text">对象赋值语句</span></a></li></ol></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E6%9E%84%E9%80%A0%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.</span> <span class="nav-text">构造造函数</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E6%99%AE%E9%80%9A%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.1.</span> <span class="nav-text">1.普通的构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%88%9D%E5%A7%8B%E5%8C%96%E5%88%97%E8%A1%A8%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0"><span class="nav-number">8.2.</span> <span class="nav-text">2.初始化列表构造函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E9%BB%98%E8%AE%A4%E7%9A%84%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0%E5%92%8C%E6%9E%90%E6%9E%84%E5%87%BD%E6%95%B0"><span class="nav-number">8.3.</span> <span class="nav-text">默认的构造函数和析构函数</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E8%87%AA%E5%BC%95%E6%8C%87%E9%92%88"><span class="nav-number">9.</span> <span class="nav-text">自引指针</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%AF%B9%E8%B1%A1%E6%95%B0%E7%BB%84"><span class="nav-number">10.</span> <span class="nav-text">对象数组</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#string%E7%B1%BB"><span class="nav-number">11.</span> <span class="nav-text">string类</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E9%9D%99%E6%80%81%E6%88%90%E5%91%98"><span class="nav-number">12.</span> <span class="nav-text">静态成员</span></a></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%8F%8B%E5%85%83"><span class="nav-number">13.</span> <span class="nav-text">友元</span></a><ol class="nav-child"><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0"><span class="nav-number">13.1.</span> <span class="nav-text">友元函数</span></a></li><li class="nav-item nav-level-3"><a class="nav-link" href="#%E5%B0%86%E6%88%90%E5%91%98%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E4%B8%BA%E5%8F%8B%E5%85%83%E5%87%BD%E6%95%B0%E4%B8%AA%E4%BA%BA%E8%AE%A4%E4%B8%BA%E8%BF%99%E4%B8%AA%E4%BA%86%E8%A7%A3%E5%B0%B1ok%E6%B2%A1%E6%9C%89%E7%AC%AC%E4%B8%80%E7%A7%8D%E6%96%B9%E4%BE%BF"><span class="nav-number">13.2.</span> <span class="nav-text">将成员函数声明为友元函数（个人认为这个了解就ok，没有第一种方便）</span></a></li></ol></li><li class="nav-item nav-level-2"><a class="nav-link" href="#%E5%B8%B8%E5%BC%95%E7%94%A8"><span class="nav-number">14.</span> <span class="nav-text">常引用</span></a></li></ol></div>
      </div>
      <!--/noindex-->

      <div class="site-overview-wrap sidebar-panel">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
  <p class="site-author-name" itemprop="name">Mrtao</p>
  <div class="site-description" itemprop="description">第一个博客网站</div>
</div>
<div class="site-state-wrap motion-element">
  <nav class="site-state">
      <div class="site-state-item site-state-posts">
          <a href="/archives/">
        
          <span class="site-state-item-count">15</span>
          <span class="site-state-item-name">日志</span>
        </a>
      </div>
      <div class="site-state-item site-state-categories">
            <a href="/categories/">
          
        <span class="site-state-item-count">10</span>
        <span class="site-state-item-name">分类</span></a>
      </div>
      <div class="site-state-item site-state-tags">
            <a href="/tags/">
          
        <span class="site-state-item-count">3</span>
        <span class="site-state-item-name">标签</span></a>
      </div>
  </nav>
</div>



      </div>

    </div>
  </aside>
  <div id="sidebar-dimmer"></div>


      </div>
    </main>

    <footer class="footer">
      <div class="footer-inner">
        

        <!-- -->

<div class="copyright">
  
  &copy; 
  <span itemprop="copyrightYear">2023</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Mrtao</span>
</div>



        








      </div>
    </footer>
  </div>

  
  <script src="/lib/anime.min.js"></script>
  <script src="/lib/velocity/velocity.min.js"></script>
  <script src="/lib/velocity/velocity.ui.min.js"></script>

<script src="/js/utils.js"></script>

<script src="/js/motion.js"></script>


<script src="/js/schemes/muse.js"></script>


<script src="/js/next-boot.js"></script>




  













<script>
if (document.querySelectorAll('pre.mermaid').length) {
  NexT.utils.getScript('//cdn.jsdelivr.net/npm/mermaid@8/dist/mermaid.min.js', () => {
    mermaid.initialize({
      theme    : 'default',
      logLevel : 3,
      flowchart: { curve     : 'linear' },
      gantt    : { axisFormat: '%m/%d/%Y' },
      sequence : { actorMargin: 50 }
    });
  }, window.mermaid);
}
</script>


  

  

  

</body>
</html>
